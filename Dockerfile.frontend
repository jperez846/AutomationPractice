# ============================================================================
# Multi-Stage Dockerfile for React Frontend
# ============================================================================
# 
# Multi-stage builds:
# - Stage 1 (builder): Builds React app (npm install & build)
# - Stage 2 (runtime): Serves static files with Nginx
# 
# Benefits:
# - Tiny production image (~25MB with Nginx Alpine)
# - No Node.js in production (only static files)
# - Fast serving with Nginx
# ============================================================================

# ============================================================================
# STAGE 1: BUILD
# ============================================================================
# 
# Use Node.js image to build React application
FROM node:20-alpine AS builder

# Set working directory
WORKDIR /app

# ============================================================================
# OPTIMIZE NPM INSTALL CACHING
# ============================================================================
# 
# Strategy: Copy package files first, install deps, then copy source
# Why? package.json changes less than source code
# Result: Faster rebuilds (npm install layer is cached)
# ============================================================================

# Copy package files
# package-lock.json ensures consistent dependency versions
COPY src/main/client/vite-project/package*.json ./

# Install dependencies
# --legacy-peer-deps: Resolves peer dependency conflicts (if any)
# Clean install using package-lock.json for reproducibility
RUN npm ci --legacy-peer-deps

# Copy application source code
COPY src/main/client/vite-project/ ./

# ============================================================================
# BUILD REACT APPLICATION
# ============================================================================
# 
# npm run build:
# - Runs Vite build process
# - Bundles and minifies JavaScript
# - Optimizes assets (images, CSS)
# - Outputs to /app/dist directory
# 
# Environment variables during build:
# - NODE_ENV=production: Optimizations enabled
# - VITE_API_BASE_URL: Backend API URL
RUN npm run build

# Verify build output
RUN echo "=== Build Complete ===" && \
    ls -lh /app/dist/

# ============================================================================
# STAGE 2: RUNTIME WITH NGINX
# ============================================================================
# 
# Nginx Alpine: Lightweight web server (~25MB)
# Perfect for serving static files (HTML, CSS, JS)
FROM nginx:alpine
RUN apk add --no-cache curl
#COPY --from=builder /app/dist /usr/share/nginx/html

# ============================================================================
# COPY BUILD ARTIFACTS
# ============================================================================
# 
# Copy built React app from builder stage to Nginx html directory
# 
# --from=builder: Copy from Stage 1
# /app/dist: Vite build output directory
# /usr/share/nginx/html: Default Nginx static file location
COPY --from=builder /app/dist /usr/share/nginx/html

# ============================================================================
# CONFIGURE NGINX
# ============================================================================
# 
# Create custom Nginx configuration
# Handles:
# - API proxy to backend
# - SPA routing (redirect all routes to index.html)
# - Gzip compression
# - Caching headers
COPY <<'EOF' /etc/nginx/conf.d/default.conf
# Nginx configuration for React SPA

server {
    # Listen on port 80 (HTTP)
    listen 80;
    
    # Server name (use your domain in production)
    server_name localhost;
    
    # Root directory for static files
    root /usr/share/nginx/html;
    
    # Default file to serve
    index index.html;
    
    # ================================================================
    # GZIP COMPRESSION
    # ================================================================
    # Compress responses to reduce bandwidth
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript 
               application/x-javascript application/xml+rss 
               application/javascript application/json;
    
    # ================================================================
    # PROXY API REQUESTS TO BACKEND
    # ================================================================
    # 
    # All requests to /api/* are forwarded to Spring Boot backend
    # This avoids CORS issues (same origin for frontend and backend)
    location /api/ {
        # Backend service URL
        # In docker-compose: service name (backend:8080)
        # In production: actual backend URL
        proxy_pass http://backend:8080;
        
        # Pass original host header
        proxy_set_header Host $host;
        
        # Pass real client IP
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # Protocol (http or https)
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
    
    # ================================================================
    # STATIC FILE CACHING
    # ================================================================
    # 
    # Cache static assets (images, fonts, etc.) for 1 year
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
    
    # ================================================================
    # SPA ROUTING (React Router)
    # ================================================================
    # 
    # For all other requests, serve index.html
    # This allows React Router to handle client-side routing
    # 
    # Why? In SPA, routes like /products/123 don't exist as files
    # Nginx would return 404, but we want React Router to handle it
    # Solution: Always serve index.html, let React handle routing
    location / {
        # Try to serve file, fallback to index.html
        try_files $uri $uri/ /index.html;
        
        # Don't cache index.html (always get latest)
        add_header Cache-Control "no-cache, must-revalidate";
    }
    
    # ================================================================
    # HEALTHCHECK ENDPOINT
    # ================================================================
    # 
    # Simple endpoint for Docker healthcheck
    location /health {
        access_log off;
        add_header Content-Type text/plain;
        return 200 "healthy\n";

    }
}
EOF

# ============================================================================
# EXPOSE PORT
# ============================================================================
# 
# Nginx listens on port 80
# This is documentation only (actual mapping in docker-compose)
EXPOSE 80

# ============================================================================
# RUN NGINX
# ============================================================================
# 
# Start Nginx in foreground (daemon off)
# Required for Docker (container stops if process runs in background)
CMD ["nginx", "-g", "daemon off;"]

# ============================================================================
# BUILD THIS IMAGE:
# docker build -f Dockerfile.frontend -t your-app-frontend:latest .
# 
# RUN THIS IMAGE:
# docker run -p 80:80 your-app-frontend:latest
# ============================================================================